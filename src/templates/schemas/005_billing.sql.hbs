-- Migration: 005_billing
-- Generated by Launchblocks for {{app_name}}
-- Run this in your Supabase SQL editor

-- ============================================================
-- SUBSCRIPTION PLANS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS public.subscription_plans (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  stripe_price_id text,
  features jsonb NOT NULL DEFAULT '{}'::jsonb,
  limits jsonb NOT NULL DEFAULT '{}'::jsonb,
  price_monthly numeric(10,2) NOT NULL DEFAULT 0,
  price_yearly numeric(10,2),
  is_active boolean NOT NULL DEFAULT true,
  sort_order integer NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.subscription_plans ENABLE ROW LEVEL SECURITY;

-- Anyone can read active plans (public pricing page)
DROP POLICY IF EXISTS "plans_select_all" ON public.subscription_plans;
CREATE POLICY "plans_select_all" ON public.subscription_plans
  FOR SELECT TO authenticated
  USING (is_active = true);

-- Only admins with manage_settings can modify plans
DROP POLICY IF EXISTS "plans_manage_admin" ON public.subscription_plans;
CREATE POLICY "plans_manage_admin" ON public.subscription_plans
  FOR ALL TO authenticated
  USING (public.has_permission(auth.uid(), 'manage_settings'))
  WITH CHECK (public.has_permission(auth.uid(), 'manage_settings'));

-- ============================================================
-- USER SUBSCRIPTIONS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS public.user_subscriptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.user_profiles(id),
  plan_id uuid NOT NULL REFERENCES public.subscription_plans(id),
  stripe_customer_id text,
  stripe_subscription_id text,
  status text NOT NULL DEFAULT 'active'
    CHECK (status IN ('active', 'past_due', 'canceled', 'trialing', 'incomplete')),
  current_period_start timestamptz,
  current_period_end timestamptz,
  cancel_at_period_end boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.user_subscriptions ENABLE ROW LEVEL SECURITY;

-- Users can view their own subscription
DROP POLICY IF EXISTS "subscriptions_select_own" ON public.user_subscriptions;
CREATE POLICY "subscriptions_select_own" ON public.user_subscriptions
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

-- Admins with manage_users can view all subscriptions
DROP POLICY IF EXISTS "subscriptions_select_admin" ON public.user_subscriptions;
CREATE POLICY "subscriptions_select_admin" ON public.user_subscriptions
  FOR SELECT TO authenticated
  USING (public.has_permission(auth.uid(), 'manage_users'));

-- Service role manages subscriptions (via webhook handlers)
DROP POLICY IF EXISTS "subscriptions_manage_service" ON public.user_subscriptions;
CREATE POLICY "subscriptions_manage_service" ON public.user_subscriptions
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

-- Allow authenticated users to create their own subscription (initial free plan)
DROP POLICY IF EXISTS "subscriptions_insert_own" ON public.user_subscriptions;
CREATE POLICY "subscriptions_insert_own" ON public.user_subscriptions
  FOR INSERT TO authenticated
  WITH CHECK (user_id = auth.uid());

-- ============================================================
-- BILLING EVENTS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS public.billing_events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES public.user_profiles(id),
  event_type text NOT NULL,
  stripe_event_id text UNIQUE NOT NULL,
  data jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.billing_events ENABLE ROW LEVEL SECURITY;

-- Only service role can insert billing events (from webhook handler)
DROP POLICY IF EXISTS "billing_events_insert_service" ON public.billing_events;
CREATE POLICY "billing_events_insert_service" ON public.billing_events
  FOR INSERT TO service_role
  WITH CHECK (true);

-- Users can view their own billing events
DROP POLICY IF EXISTS "billing_events_select_own" ON public.billing_events;
CREATE POLICY "billing_events_select_own" ON public.billing_events
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

-- Admins with manage_settings can view billing events
DROP POLICY IF EXISTS "billing_events_select_admin" ON public.billing_events;
CREATE POLICY "billing_events_select_admin" ON public.billing_events
  FOR SELECT TO authenticated
  USING (public.has_permission(auth.uid(), 'manage_settings'));

{{#if is_usage_based}}
-- ============================================================
-- USAGE RECORDS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS public.usage_records (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.user_profiles(id),
  period_start timestamptz NOT NULL,
  period_end timestamptz NOT NULL,
  llm_calls integer NOT NULL DEFAULT 0,
  tokens_used bigint NOT NULL DEFAULT 0,
  estimated_cost numeric(10,6) NOT NULL DEFAULT 0,
  reported_to_stripe boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.usage_records ENABLE ROW LEVEL SECURITY;

-- Users can view their own usage
DROP POLICY IF EXISTS "usage_select_own" ON public.usage_records;
CREATE POLICY "usage_select_own" ON public.usage_records
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

-- Service role manages usage records
DROP POLICY IF EXISTS "usage_manage_service" ON public.usage_records;
CREATE POLICY "usage_manage_service" ON public.usage_records
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

-- Admins can view all usage
DROP POLICY IF EXISTS "usage_select_admin" ON public.usage_records;
CREATE POLICY "usage_select_admin" ON public.usage_records
  FOR SELECT TO authenticated
  USING (public.has_permission(auth.uid(), 'manage_settings'));

{{/if}}
-- ============================================================
-- INDEXES
-- ============================================================

CREATE INDEX IF NOT EXISTS idx_subscription_plans_slug ON public.subscription_plans(slug);
CREATE INDEX IF NOT EXISTS idx_subscription_plans_active ON public.subscription_plans(is_active);

CREATE INDEX IF NOT EXISTS idx_user_subscriptions_user ON public.user_subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_plan ON public.user_subscriptions(plan_id);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_stripe_customer ON public.user_subscriptions(stripe_customer_id);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_status ON public.user_subscriptions(status);

CREATE INDEX IF NOT EXISTS idx_billing_events_user ON public.billing_events(user_id);
CREATE INDEX IF NOT EXISTS idx_billing_events_type ON public.billing_events(event_type);
CREATE INDEX IF NOT EXISTS idx_billing_events_stripe_id ON public.billing_events(stripe_event_id);
CREATE INDEX IF NOT EXISTS idx_billing_events_created ON public.billing_events(created_at DESC);

{{#if is_usage_based}}
CREATE INDEX IF NOT EXISTS idx_usage_records_user ON public.usage_records(user_id);
CREATE INDEX IF NOT EXISTS idx_usage_records_period ON public.usage_records(period_start, period_end);

{{/if}}
-- ============================================================
-- HELPER FUNCTION: Get user's current plan
-- ============================================================

CREATE OR REPLACE FUNCTION public.get_user_plan(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result jsonb;
BEGIN
  SELECT jsonb_build_object(
    'plan_name', sp.name,
    'plan_slug', sp.slug,
    'status', us.status,
    'features', sp.features,
    'limits', sp.limits,
    'current_period_end', us.current_period_end
  ) INTO result
  FROM public.user_subscriptions us
  JOIN public.subscription_plans sp ON sp.id = us.plan_id
  WHERE us.user_id = p_user_id
    AND us.status IN ('active', 'trialing')
  ORDER BY us.created_at DESC
  LIMIT 1;

  -- Default to free plan if no active subscription
  IF result IS NULL THEN
    SELECT jsonb_build_object(
      'plan_name', sp.name,
      'plan_slug', sp.slug,
      'status', 'active',
      'features', sp.features,
      'limits', sp.limits,
      'current_period_end', null
    ) INTO result
    FROM public.subscription_plans sp
    WHERE sp.slug = 'free' AND sp.is_active = true;
  END IF;

  RETURN COALESCE(result, '{}'::jsonb);
END;
$$;

-- ============================================================
-- SEED DATA: Default Subscription Plans
-- ============================================================

INSERT INTO public.subscription_plans (name, slug, features, limits, price_monthly, price_yearly, sort_order) VALUES
  ('Free', 'free',
   '{"max_prompts": 3, "max_llm_calls_per_day": 50}'::jsonb,
   '{"llm_calls_per_month": 1500, "tokens_per_month": 500000}'::jsonb,
   0, null, 1),
  ('Pro', 'pro',
   '{"max_prompts": -1, "max_llm_calls_per_day": 500, "priority_support": true}'::jsonb,
   '{"llm_calls_per_month": 15000, "tokens_per_month": 5000000}'::jsonb,
   29, 290, 2),
  ('Enterprise', 'enterprise',
   '{"max_prompts": -1, "max_llm_calls_per_day": -1, "priority_support": true, "team_features": true}'::jsonb,
   '{"llm_calls_per_month": -1, "tokens_per_month": -1}'::jsonb,
   99, 990, 3)
ON CONFLICT (slug) DO NOTHING;

-- NOTE: After creating Products and Prices in the Stripe Dashboard,
-- update the stripe_price_id for each plan:
--
-- UPDATE public.subscription_plans SET stripe_price_id = 'price_xxx' WHERE slug = 'pro';
-- UPDATE public.subscription_plans SET stripe_price_id = 'price_yyy' WHERE slug = 'enterprise';
