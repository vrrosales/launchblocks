# Module 8: Billing

> Spec for **{{app_name}}** -- generated by Launchblocks

## Purpose

The Billing module integrates Stripe to handle {{#if is_billing_both}}subscription plans and usage-based billing for LLM calls{{else}}{{#if is_subscription}}subscription-based billing with tiered plans{{else}}usage-based billing where users pay per LLM call{{/if}}{{/if}}. It provides checkout flows, webhook handling for payment events, a customer portal for self-service management, and plan-based feature gating.

## Authorization

| Action | Required Permission | Roles |
|---|---|---|
| View own subscription | (any authenticated user) | {{role_names_joined}} |
| Manage billing settings | `manage_settings` | {{#each role_permission_summary}}{{#if has_permissions}}{{this.name}}{{#unless @last}}, {{/unless}}{{/if}}{{/each}} |
| View all subscriptions (admin) | `manage_users` | {{#each role_permission_summary}}{{#if has_permissions}}{{this.name}}{{#unless @last}}, {{/unless}}{{/if}}{{/each}} |

## Database Schema

The billing module uses tables created in migration `005_billing.sql`:

### `subscription_plans` Table

| Column | Type | Description |
|---|---|---|
| `id` | uuid | Primary key |
| `name` | text | Plan name (e.g., "Free", "Pro", "Enterprise") |
| `slug` | text (UNIQUE) | URL-safe identifier |
| `stripe_price_id` | text | Stripe Price ID for this plan |
| `features` | jsonb | Feature flags for plan gating (e.g., `{"max_prompts": 10, "max_llm_calls_per_day": 100}`) |
| `limits` | jsonb | Usage limits (e.g., `{"llm_calls_per_month": 1000, "tokens_per_month": 500000}`) |
| `price_monthly` | numeric(10,2) | Monthly price in USD (for display) |
| `price_yearly` | numeric(10,2) | Yearly price in USD (for display, nullable) |
| `is_active` | boolean | Whether this plan is available for new subscriptions |
| `sort_order` | integer | Display ordering |
| `created_at` | timestamptz | When the plan was created |

### `user_subscriptions` Table

| Column | Type | Description |
|---|---|---|
| `id` | uuid | Primary key |
| `user_id` | uuid | FK to `user_profiles.id` |
| `plan_id` | uuid | FK to `subscription_plans.id` |
| `stripe_customer_id` | text | Stripe Customer ID |
| `stripe_subscription_id` | text | Stripe Subscription ID (nullable for free plan) |
| `status` | text | `active`, `past_due`, `canceled`, `trialing`, `incomplete` |
| `current_period_start` | timestamptz | Start of current billing period |
| `current_period_end` | timestamptz | End of current billing period |
| `cancel_at_period_end` | boolean | Whether subscription cancels at period end |
| `created_at` | timestamptz | When the subscription was created |
| `updated_at` | timestamptz | Last update timestamp |

### `billing_events` Table

| Column | Type | Description |
|---|---|---|
| `id` | uuid | Primary key |
| `user_id` | uuid | FK to `user_profiles.id` |
| `event_type` | text | Stripe event type (e.g., `invoice.paid`, `customer.subscription.updated`) |
| `stripe_event_id` | text (UNIQUE) | Stripe Event ID for idempotency |
| `data` | jsonb | Full event payload from Stripe |
| `created_at` | timestamptz | When the event was received |

{{#if is_usage_based}}
### `usage_records` Table

| Column | Type | Description |
|---|---|---|
| `id` | uuid | Primary key |
| `user_id` | uuid | FK to `user_profiles.id` |
| `period_start` | timestamptz | Start of the usage period |
| `period_end` | timestamptz | End of the usage period |
| `llm_calls` | integer | Number of LLM calls in this period |
| `tokens_used` | bigint | Total tokens consumed |
| `estimated_cost` | numeric(10,6) | Estimated cost for the period |
| `reported_to_stripe` | boolean | Whether usage has been reported to Stripe |
| `created_at` | timestamptz | When the record was created |

{{/if}}
## Stripe Integration

### Setup Requirements

1. Create a Stripe account and get API keys
2. Set environment variables:
   - `STRIPE_SECRET_KEY` — Server-side API key
   - `STRIPE_WEBHOOK_SECRET` — Webhook endpoint signing secret
   - `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY` — Client-side publishable key
3. Create Products and Prices in the Stripe Dashboard (or via API)
4. Set up webhook endpoint pointing to `/api/billing/webhook`

### Webhook Events to Handle

| Event | Action |
|---|---|
| `checkout.session.completed` | Create/update `user_subscriptions` record |
| `customer.subscription.created` | Set subscription status to `active` |
| `customer.subscription.updated` | Update plan, status, and period dates |
| `customer.subscription.deleted` | Set status to `canceled`, revert to free plan |
| `invoice.paid` | Log successful payment in `billing_events` |
| `invoice.payment_failed` | Set status to `past_due`, notify user |
{{#if is_usage_based}}
| `invoice.upcoming` | Report current usage to Stripe |
{{/if}}

### Webhook Implementation

1. Verify the webhook signature using `STRIPE_WEBHOOK_SECRET`
2. Parse the event and check `stripe_event_id` for idempotency (skip if already processed)
3. Handle the event type (switch/case on `event.type`)
4. Store the event in `billing_events` table
5. Return 200 to Stripe immediately (process async if needed)

## Checkout Flow

### Creating a Checkout Session

When a user selects a plan:

1. Look up the plan's `stripe_price_id` from `subscription_plans`
2. Get or create a Stripe Customer for the user (store `stripe_customer_id` in `user_subscriptions`)
3. Create a Stripe Checkout Session with:
   - `mode: "subscription"`
   - `customer`: the Stripe Customer ID
   - `line_items`: the plan's price
   - `success_url`: `/dashboard/billing?success=true`
   - `cancel_url`: `/dashboard/billing?canceled=true`
   - `metadata`: `{ user_id, plan_slug }`
4. Redirect the user to the Checkout Session URL

### Customer Portal

Allow users to manage their subscription (update payment method, cancel, view invoices) via Stripe's hosted Customer Portal:

1. Create a portal session with `stripe.billingPortal.sessions.create()`
2. Pass `customer`: the user's `stripe_customer_id`
3. Set `return_url`: `/dashboard/billing`
4. Redirect to the portal URL

{{#if is_subscription}}
## Subscription Plans

### Default Plans

Seed the `subscription_plans` table with these default plans:

| Plan | Price | Features | Limits |
|---|---|---|---|
| Free | $0/mo | Basic access | 50 LLM calls/day, 3 prompt templates |
| Pro | $29/mo | Full access, priority support | 500 LLM calls/day, unlimited templates |
| Enterprise | $99/mo | Everything + team features | Unlimited LLM calls, unlimited templates |

Customize these plans in the Stripe Dashboard and update the `stripe_price_id` in the database.

{{/if}}
{{#if is_usage_based}}
## Usage-Based Billing

### Usage Tracking

1. After each LLM call logged in `llm_audit_log`, increment the user's usage counter in `usage_records`
2. At the end of each billing period (triggered by `invoice.upcoming` webhook), report the usage to Stripe using Metered Billing:
   ```
   stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
     quantity: totalLlmCalls,
     timestamp: periodEnd,
     action: 'set'
   })
   ```
3. Stripe then calculates the charge based on the per-unit price

### Usage Limits

Check usage limits before allowing LLM calls:

1. Query `usage_records` for the current period
2. Compare against the plan's `limits.llm_calls_per_month` and `limits.tokens_per_month`
3. If over limit, return 429 with a clear message about upgrading

{{/if}}
## Plan Gating

### Checking Plan Features

Create a helper function to check if a user's plan includes a specific feature:

```typescript
async function checkPlanFeature(userId: string, feature: string): Promise<boolean> {
  // 1. Get user's active subscription
  // 2. Look up the plan's features JSONB
  // 3. Return whether the feature is enabled
}
```

### Gating Rules

Apply plan-based restrictions in these areas:

- **LLM calls per day** — Check before proxying to the LLM gateway
- **Prompt template count** — Check before creating new templates
- **Model access** — Some models may be restricted to higher plans
{{#if is_usage_based}}
- **Token limits** — Track cumulative token usage per billing period
{{/if}}

When a user hits a limit, show a clear upgrade prompt with a link to the billing page.

## Screens

| Route | Page | Access |
|---|---|---|
| `/dashboard/billing` | Billing Overview | Any authenticated user |
| `/dashboard/billing/plans` | Plan Selection | Any authenticated user |
| `/admin/billing` | Billing Admin | `manage_settings` permission |

### Billing Overview Page (`/dashboard/billing`)

Display:
- Current plan name and status
- Current billing period dates
- Next payment date and amount
{{#if is_usage_based}}
- Current usage vs. limits (progress bars)
{{/if}}
- "Manage Subscription" button (opens Stripe Customer Portal)
- "Change Plan" button (links to plan selection)
- Recent invoices list

### Plan Selection Page (`/dashboard/billing/plans`)

Display:
- Plan comparison table (features, limits, pricing)
- Current plan highlighted
- "Select Plan" buttons that initiate checkout
- Monthly/yearly toggle (if yearly pricing exists)

### Billing Admin Page (`/admin/billing`)

Display:
- Total active subscriptions by plan
- Revenue summary (MRR, ARR)
{{#if is_usage_based}}
- Usage statistics across all users
{{/if}}
- List of users with billing status

## API Endpoints

### `POST /api/billing/checkout`

Create a Stripe Checkout Session for plan upgrade/downgrade.

**Request:**
```json
{
  "plan_slug": "pro",
  "billing_interval": "monthly"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "checkout_url": "https://checkout.stripe.com/..."
  }
}
```

### `POST /api/billing/portal`

Create a Stripe Customer Portal session.

**Response:**
```json
{
  "success": true,
  "data": {
    "portal_url": "https://billing.stripe.com/..."
  }
}
```

### `GET /api/billing/subscription`

Get the current user's subscription details.

**Response:**
```json
{
  "success": true,
  "data": {
    "plan": {
      "name": "Pro",
      "slug": "pro",
      "features": { "max_prompts": -1, "max_llm_calls_per_day": 500 },
      "limits": { "llm_calls_per_month": 15000, "tokens_per_month": 5000000 }
    },
    "status": "active",
    "current_period_start": "2025-01-01T00:00:00Z",
    "current_period_end": "2025-02-01T00:00:00Z",
    "cancel_at_period_end": false
  }
}
```

### `GET /api/billing/plans`

List all active subscription plans.

**Response:**
```json
{
  "success": true,
  "data": [
    {
      "name": "Free",
      "slug": "free",
      "price_monthly": 0,
      "price_yearly": null,
      "features": { "max_prompts": 3, "max_llm_calls_per_day": 50 },
      "limits": { "llm_calls_per_month": 1500, "tokens_per_month": 500000 }
    }
  ]
}
```

### `POST /api/billing/webhook`

Stripe webhook endpoint. Must verify the signature and handle events idempotently.

**Note:** This endpoint must accept raw body (not JSON-parsed) for signature verification. Configure Next.js to skip body parsing for this route.

{{#if is_usage_based}}
### `GET /api/billing/usage`

Get the current user's usage for the current billing period.

**Response:**
```json
{
  "success": true,
  "data": {
    "period_start": "2025-01-01T00:00:00Z",
    "period_end": "2025-02-01T00:00:00Z",
    "llm_calls": 142,
    "tokens_used": 523000,
    "limits": {
      "llm_calls_per_month": 15000,
      "tokens_per_month": 5000000
    }
  }
}
```

{{/if}}
## Implementation Tasks

Complete these tasks in order. Each task builds on the previous ones.

### Task 8.1: Install Stripe SDK and Configure Environment
Install the `stripe` npm package. Add `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`, and `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY` to `.env.local`. Create a Stripe client utility at `src/lib/stripe/client.ts`.
**Verify:** Import the Stripe client and call `stripe.accounts.retrieve()` to confirm the connection works.

### Task 8.2: Run Billing Migration
Run `005_billing.sql` in the Supabase SQL editor to create `subscription_plans`, `user_subscriptions`, `billing_events`{{#if is_usage_based}}, `usage_records`{{/if}} tables with RLS policies.
**Verify:** Query `subscription_plans` and confirm the seed data (Free, Pro, Enterprise plans) exists.

### Task 8.3: Build Subscription Plans API
Implement `GET /api/billing/plans` to list active plans from the `subscription_plans` table.
**Verify:** Call the API and confirm all seeded plans are returned with correct features and limits.

### Task 8.4: Build Checkout Session API
Implement `POST /api/billing/checkout` that creates a Stripe Checkout Session. Get or create a Stripe Customer, then redirect to Stripe's hosted checkout page.
**Verify:** Call the API with a plan slug, confirm a valid Stripe Checkout URL is returned, and the redirect works.

### Task 8.5: Build Webhook Handler
Implement `POST /api/billing/webhook` to receive and verify Stripe webhook events. Handle `checkout.session.completed`, `customer.subscription.created`, `customer.subscription.updated`, `customer.subscription.deleted`, `invoice.paid`, and `invoice.payment_failed`. Store events in `billing_events` for idempotency.
**Verify:** Use Stripe CLI (`stripe trigger checkout.session.completed`) to send a test event and confirm the `user_subscriptions` record is created/updated.

### Task 8.6: Build Customer Portal API
Implement `POST /api/billing/portal` that creates a Stripe Customer Portal session for subscription management.
**Verify:** Call the API and confirm a valid Stripe Portal URL is returned.

### Task 8.7: Build Subscription Status API
Implement `GET /api/billing/subscription` to return the current user's subscription details (plan, status, period dates, cancel status).
**Verify:** Call the API as a subscribed user and confirm correct subscription data is returned.

### Task 8.8: Implement Plan Gating
Create a `checkPlanFeature()` helper and add plan-based checks to the LLM gateway (`/api/llm/chat`) and prompt management routes. Return 429 when limits are exceeded.
**Verify:** A user on the Free plan hitting the daily LLM call limit receives a 429 response with an upgrade message.

{{#if is_usage_based}}
### Task 8.9: Implement Usage Tracking
After each LLM call, increment the usage counter in `usage_records`. Add a `GET /api/billing/usage` endpoint. Report usage to Stripe on `invoice.upcoming` webhook.
**Verify:** Make several LLM calls, then check `/api/billing/usage` shows the correct count and token totals.

{{/if}}
### Task 8.{{#if is_usage_based}}10{{else}}9{{/if}}: Build Billing Overview Page
Create `/dashboard/billing` showing current plan, status, billing period, payment info{{#if is_usage_based}}, usage progress bars{{/if}}, "Manage Subscription" button (Customer Portal), and "Change Plan" link.
**Verify:** The page renders correctly showing the user's current subscription details.

### Task 8.{{#if is_usage_based}}11{{else}}10{{/if}}: Build Plan Selection Page
Create `/dashboard/billing/plans` with a plan comparison table, current plan highlighted, and "Select Plan" buttons that trigger the checkout flow.
**Verify:** Selecting a plan initiates the Stripe Checkout flow and redirects to the Stripe checkout page.

### Task 8.{{#if is_usage_based}}12{{else}}11{{/if}}: Build Billing Admin Page
Create `/admin/billing` showing subscription counts by plan, MRR/ARR metrics{{#if is_usage_based}}, aggregate usage statistics{{/if}}, and a user billing status list. Requires `manage_settings` permission.
**Verify:** Admin can view billing overview with correct subscription counts and revenue data.

---

## Test Specifications

### Unit Tests
- [ ] `checkPlanFeature()` returns true for features included in the user's plan
- [ ] `checkPlanFeature()` returns false for features not in the user's plan
- [ ] Free plan users have correct default limits applied
- [ ] Stripe webhook signature verification rejects invalid signatures
- [ ] Duplicate Stripe events (same `stripe_event_id`) are handled idempotently
- [ ] Checkout session creation includes correct metadata (user_id, plan_slug)
{{#if is_usage_based}}
- [ ] Usage counter correctly increments after each LLM call
- [ ] Usage limit check correctly compares current usage against plan limits
{{/if}}

### Integration Tests
- [ ] Creating a checkout session returns a valid Stripe URL
- [ ] Webhook handler creates `user_subscriptions` record on `checkout.session.completed`
- [ ] Webhook handler updates subscription status on `customer.subscription.updated`
- [ ] Webhook handler reverts to free plan on `customer.subscription.deleted`
- [ ] Webhook handler logs all events to `billing_events` table
- [ ] Customer portal session creation returns a valid URL
- [ ] Subscription API returns correct plan details for the authenticated user
- [ ] Plans API returns only active plans, sorted by `sort_order`
- [ ] RLS policies restrict `user_subscriptions` to the owning user
- [ ] RLS policies allow admins to read all subscriptions
{{#if is_usage_based}}
- [ ] Usage reporting to Stripe sends correct quantities
- [ ] Usage records are created and updated correctly per billing period
{{/if}}

### E2E Tests
- [ ] User views billing page → sees current plan → clicks "Change Plan" → selects Pro → completes Stripe checkout → billing page shows Pro plan
- [ ] User clicks "Manage Subscription" → redirected to Stripe Portal → returns to billing page
- [ ] Free plan user exceeds daily LLM call limit → receives 429 error → sees upgrade prompt
- [ ] Admin views billing admin page → sees subscription counts and revenue metrics
- [ ] User on canceled plan → status shows "Canceling at period end" → after period end, reverts to Free
{{#if is_usage_based}}
- [ ] User views billing page → sees usage progress bars → usage updates after LLM calls
{{/if}}
