---
phase: 02-cli-hardening
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/commands/init.ts
  - src/commands/add.ts
autonomous: true
requirements: [CLI-02, CLI-03, CLI-04, CFG-03]

must_haves:
  truths:
    - "Running --defaults --roles 'admin,user,moderator' produces a config with exactly those three roles and adminRoles set to [ownerRole] which passes validateConfig"
    - "Running add role on an existing project validates the mutated config before generation and rejects invalid additions"
    - "Running add provider on an existing project validates the mutated config before generation and rejects duplicates"
    - "The add role command produces output equivalent to what init would produce with the role pre-included"
    - "The add provider command produces output equivalent to what init would produce with the provider pre-included"
    - "The project builds cleanly with npm run build after all changes"
  artifacts:
    - path: "src/commands/init.ts"
      provides: "Correct --defaults + individual flag merging for adminRoles"
      contains: "buildAnswersFromFlags"
    - path: "src/commands/add.ts"
      provides: "Post-mutation validateConfig call before generateProject"
      contains: "validateConfig"
  key_links:
    - from: "src/commands/add.ts"
      to: "src/generator/config-reader.ts"
      via: "import and call validateConfig after mutation"
      pattern: "validateConfig.*config"
    - from: "src/commands/add.ts"
      to: "src/generator/config-reader.ts"
      via: "import ConfigValidationError for catch"
      pattern: "ConfigValidationError"
---

<objective>
Fix --defaults flag merging with individual flags, and add post-mutation config validation to the `add role` and `add provider` commands so invalid additions are rejected before generation.

Purpose: Ensure every CLI flag combination produces correct, validated output, and that scoped regeneration via `add` commands maintains config consistency by running the same validation as the `init` path.

Output: Corrected `buildAnswersFromFlags` in init.ts; `validateConfig` calls in both add commands in add.ts.
</objective>

<execution_context>
@/Users/vrrosales/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vrrosales/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-hardening/02-RESEARCH.md
@.planning/phases/02-cli-hardening/02-01-SUMMARY.md

@src/commands/init.ts
@src/commands/add.ts
@src/generator/config-reader.ts
@src/interview/types.ts

<interfaces>
<!-- From src/generator/config-reader.ts — used for post-mutation validation -->
export class ConfigValidationError extends Error {
  public readonly errors: string[];
  constructor(errors: string[]) { ... }
}

export function validateConfig(raw: unknown): LaunchblocksConfig;

<!-- From src/interview/types.ts — DEFAULT_ANSWERS shape -->
export const DEFAULT_ANSWERS: InterviewAnswers = {
  appName: "my-app",
  roles: [
    { name: "super_admin", display_name: "Super Admin", is_owner_role: true, is_default_role: false, permissions: [...ALL_PERMISSIONS] },
    { name: "admin", display_name: "Admin", is_owner_role: false, is_default_role: false, permissions: [...] },
    { name: "user", display_name: "User", is_owner_role: false, is_default_role: true, permissions: [...] },
  ],
  ownerRole: "super_admin",
  defaultRole: "user",
  requireApproval: false,
  adminRoles: ["super_admin", "admin"],
  llmAccessRoles: ["super_admin", "admin", "user"],
  llmProviders: [...DEFAULT_LLM_PROVIDERS],
  aiTool: "claude",
  includeBilling: false,
  billingModel: undefined,
};
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and fix --defaults flag merging for adminRoles and llmAccessRoles</name>
  <files>src/commands/init.ts</files>
  <action>
The `--defaults --roles` path has a correctness consideration: when custom roles are provided via `--roles`, the `DEFAULT_ANSWERS.adminRoles` value `["super_admin", "admin"]` gets overwritten by `buildAnswersFromFlags`'s `partial.adminRoles = [ownerRole]`. This is CORRECT behavior because:
- The default admin roles reference role names ("super_admin", "admin") that may not exist in the custom roles list
- `validateConfig` (from Phase 1) would catch an `adminRoles` array containing non-existent role names
- Setting `adminRoles = [ownerRole]` is the safe default when there's no explicit `--admin-roles` flag

The current code is therefore correct for `adminRoles`. However, verify and add a defensive check:

1. In `buildAnswersFromFlags`, the `adminRoles` inference at line 94 (`partial.adminRoles = [ownerRole]`) should also include any roles whose name contains "admin" (matching the heuristic from `askAdminAccess`). Update to:
   ```typescript
   // Infer admin roles: owner + roles whose name contains "admin"
   partial.adminRoles = [ownerRole, ...roleNames.filter(r => r !== ownerRole && r.includes("admin"))];
   ```
   This ensures that `--defaults --roles "admin,user,moderator"` produces `adminRoles: ["admin"]` (owner "admin" is already included), and `--defaults --roles "owner,admin,user"` produces `adminRoles: ["owner", "admin"]` (owner + the role containing "admin").

2. In the `--defaults` path of `initCommand` (lines 225-233), the `llmAccessRoles` resolution is correct: when `opts.llmAccess` is not set, it resolves to all role names from `answers.roles` (which already has the custom roles from the spread). Verify this path is correct and leave it unchanged.

3. After the `answers = { ...DEFAULT_ANSWERS, ...flagOverrides }` line, add a validation step to ensure the merged answers are consistent. Call `buildConfig(answers)` (which already happens at line 253) and then validate the config. Actually, `buildConfig` + `validateConfig` are redundant because `buildConfig` produces a valid config by construction. The important thing is that the `adminRoles` heuristic produces values that exist in the roles list. The improved heuristic in step 1 handles this.

IMPORTANT: Do not change the overall --defaults flow. Only update the adminRoles inference heuristic in `buildAnswersFromFlags`.
  </action>
  <verify>
    <automated>cd /Users/vrrosales/Desktop/Coding/VibeKit-cli && npm run build 2>&1 | tail -3</automated>
  </verify>
  <done>
    - `buildAnswersFromFlags` infers admin roles as owner + roles containing "admin" in their name
    - The `--defaults` path produces consistent answers where all `adminRoles` entries exist in the `roles` array
    - `npm run build` succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Add post-mutation validateConfig to add role and add provider commands</name>
  <files>src/commands/add.ts</files>
  <action>
1. Add imports to `src/commands/add.ts`:
   ```typescript
   import { readConfig, validateConfig, ConfigValidationError, VALID_PROVIDERS, VALID_PERMISSIONS } from "../generator/config-reader.js";
   ```
   (Add `validateConfig` and `ConfigValidationError` to the existing import from config-reader.js)

2. In `addRoleCommand`, after all config mutations are complete (after line 126 where `llm_access_roles` is updated) and BEFORE the `logger.step("Regenerating project files...")` line, add:
   ```typescript
   // Validate the mutated config before generation (CFG-03)
   try {
     validateConfig(config);
   } catch (err) {
     if (err instanceof ConfigValidationError) {
       logger.error(err.message);
       process.exit(1);
     }
     throw err;
   }
   ```
   This catches logical errors like duplicate roles (already checked manually above, but validateConfig is the comprehensive check) and cross-reference violations (e.g., if --owner creates an owner_role that somehow conflicts).

3. In `addProviderCommand`, after the provider is pushed to `config.llm_providers` (after line 186) and BEFORE `logger.step("Regenerating project files...")`, add the same validateConfig call:
   ```typescript
   // Validate the mutated config before generation (CFG-03)
   try {
     validateConfig(config);
   } catch (err) {
     if (err instanceof ConfigValidationError) {
       logger.error(err.message);
       process.exit(1);
     }
     throw err;
   }
   ```

4. The existing manual checks (duplicate role at line 47, duplicate provider at line 180, invalid provider at line 164) remain as fast-fail guards. `validateConfig` serves as a comprehensive backstop that catches any validation issue the manual checks might miss.

5. Verify the build succeeds: `npm run build`

NOTE: `validateConfig` accepts `unknown` but TypeScript allows passing a typed `LaunchblocksConfig` to an `unknown` parameter (widening). No cast needed.
  </action>
  <verify>
    <automated>cd /Users/vrrosales/Desktop/Coding/VibeKit-cli && npm run build 2>&1 | tail -3 && grep -c "validateConfig" src/commands/add.ts | xargs test 2 -eq && echo "PASS: validateConfig called in both add commands" || echo "FAIL: validateConfig not found in both add commands"</automated>
  </verify>
  <done>
    - `addRoleCommand` calls `validateConfig(config)` after all mutations and before `generateProject`
    - `addProviderCommand` calls `validateConfig(config)` after mutation and before `generateProject`
    - `ConfigValidationError` is caught and logged with `logger.error` + `process.exit(1)` (consistent with existing error pattern)
    - `npm run build` succeeds with no errors
    - The existing test (`npx tsx test/test-generator.ts`) still passes
  </done>
</task>

</tasks>

<verification>
1. `grep -n "adminRoles.*ownerRole" src/commands/init.ts` shows the improved heuristic including admin-named roles
2. `grep -n "validateConfig" src/commands/add.ts` shows 2 calls (one in addRoleCommand, one in addProviderCommand)
3. `grep -n "ConfigValidationError" src/commands/add.ts` shows the import and catch blocks
4. `npm run build` succeeds
5. `npx tsx test/test-generator.ts` passes (existing test)
</verification>

<success_criteria>
- `buildAnswersFromFlags` infers `adminRoles` as owner + roles whose name contains "admin"
- Both `addRoleCommand` and `addProviderCommand` call `validateConfig` on the mutated config before passing to `generateProject`
- Invalid mutations (caught by validateConfig) produce a clear error message and exit with code 1
- `npm run build` succeeds
- Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-hardening/02-02-SUMMARY.md`
</output>
